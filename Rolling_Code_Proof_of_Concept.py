import binascii
import logging
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

class LFSR:
    def __init__(self, taps, initial_state_hex, num_bits):
        """
        Initializes an LFSR (Linear Feedback Shift Register) object.

        Parameters:
        - taps (list): A list of tap positions in the LFSR.
        - initial_state_hex (str): The initial state of the LFSR in hexadecimal representation.
        - num_bits (int): The number of bits in the LFSR.

        Returns:
        None
        """
        # Convert the hexadecimal representation to a binary list with the specified number of bits
        self.state = [int(bit) for bit in format(initial_state_hex, f'0{num_bits}b')]
        self.taps = taps

    def shift(self):
        """
        Performs a shift operation on the LFSR.

        Returns:
        int: The feedback bit obtained from the shift operation.
        """
        feedback_bit = sum(self.state[tap] for tap in self.taps) % 2
        self.state = [feedback_bit] + self.state[:-1]
        return feedback_bit

    def get_state_hex(self):
        """
        Returns the current state of the LFSR in hexadecimal representation.

        Returns:
        str: The current state of the LFSR in hexadecimal.
        """
        # Convert the binary list to an integer and then to a hexadecimal string
        state_int = int(''.join(map(str, self.state)), 2)
        return hex(state_int)
    
    def set_state(self, new_state_hex, num_bits=64):
        """
        Sets the state of the LFSR to a new value.

        Parameters:
        - new_state_hex (str): The new state of the LFSR in hexadecimal representation.

        Returns:
        None
        """
        self.state = [int(bit) for bit in format(new_state_hex, f'0{num_bits}b')]

class RemoteReceiver:
    def __init__(self, master_key,taps, initial_state_hex, num_bits):
        """
        Initializes a RemoteSender object.

        Parameters:
        - serial_number (int): The serial number of the remote sender.
        - taps (list): A list of tap positions in the LFSR.
        - initial_state_hex (str): The initial state of the LFSR in hexadecimal representation.
        - num_bits (int): The number of bits in the LFSR.

        Returns:
        None
        """
        self.master_key = master_key
        self.lfsr = LFSR(taps, initial_state_hex, num_bits)

        
    def update_lfsr_and_values(self, new_state_hex, num_values):
        """
        Updates the LFSR with a new initial state and regenerates the lfsr_values list.

        Parameters:
        - lfsr (LFSR): The LFSR object to update.
        - new_state_hex (str): The new initial state for the LFSR in hexadecimal representation.
        - num_values (int): The number of values to generate for the lfsr_values list.

        Returns:
        - list: The new lfsr_values list.
        """
        lfsr_values = []

        self.lfsr.set_state(new_state_hex)
        
        for _ in range(num_values):
            self.lfsr.shift()
            lfsr_values.append(self.lfsr.get_state_hex())

        return lfsr_values

    def generate_rolling_code_values(self, num_values=10):
        """
        Generates a list of rolling code values using the LFSR.

        Parameters:
        - num_values (int, optional): The number of rolling code values to generate. Defaults to 10.

        Returns:
        list: A list of rolling code values generated by the LFSR.
        """
        lfsr_values = []

        for _ in range(num_values):
            self.lfsr.shift()
            lfsr_values.append(self.lfsr.get_state_hex())

        return lfsr_values
    
    def generate_sender_key(self, serial_number):
        """
        Generates a sender key by encrypting the given serial number using the master key.

        Args:
            serial_number (bytes): The serial number to be encrypted.

        Returns:
            bytes: The encrypted sender key.
        """
        sender_key = AES.new(self.master_key, AES.MODE_ECB)
        return sender_key.encrypt(pad(serial_number, AES.block_size))
    
    def generate_token(self, serial_number ,raw_token):
        """
        Generates a token using the LFSR.

        Returns:
        str: A token generated by the LFSR.
        """
        sender_key = self.generate_sender_key(serial_number)
        token = AES.new(sender_key, AES.MODE_ECB)

        return token.encrypt(pad(raw_token, AES.block_size))
    
class RemoteSender:
    def __init__(self, serial_number, sender_key,taps, initial_state_hex, num_bits):
        """
        Initializes a RemoteSender object.

        Parameters:
        - serial_number (int): The serial number of the remote sender.
        - taps (list): A list of tap positions in the LFSR.
        - initial_state_hex (str): The initial state of the LFSR in hexadecimal representation.
        - num_bits (int): The number of bits in the LFSR.

        Returns:
        None
        """
        self.sender_key = sender_key
        self.serial_number = serial_number
        self.lfsr = LFSR(taps, initial_state_hex, num_bits)
 
    def update_lfsr_and_values(self, new_state_hex, num_values):
        """
        Updates the LFSR with a new initial state and regenerates the lfsr_values list.

        Parameters:
        - lfsr (LFSR): The LFSR object to update.
        - new_state_hex (str): The new initial state for the LFSR in hexadecimal representation.
        - num_values (int): The number of values to generate for the lfsr_values list.

        Returns:
        - list: The new lfsr_values list.
        """
        lfsr_values = []

        self.lfsr.set_state(new_state_hex)
        
        for _ in range(num_values):
            self.lfsr.shift()
            lfsr_values.append(self.lfsr.get_state_hex())

        return lfsr_values

    def generate_rolling_code_values(self, num_values=1):
        """
        Generates a list of rolling code values using the LFSR.

        Parameters:
        - num_values (int, optional): The number of rolling code values to generate. Defaults to 10.

        Returns:
        list: A list of rolling code values generated by the LFSR.
        """
        lfsr_values = []

        for _ in range(num_values):
            self.lfsr.shift()
            lfsr_values.append(self.lfsr.get_state_hex())

        return lfsr_values
    
    def generate_token(self, raw_token):
        """
        Generates a token using the LFSR.

        Returns:
        str: A token generated by the LFSR.
        """
        token = AES.new(self.sender_key, AES.MODE_ECB)
        return token.encrypt(pad(raw_token, AES.block_size))

#------------------------------------------------------------------------------------------#

# Dummy Master Key, Must be 16 bytes length
""" KEEP THIS KEY SECRET IN REAL LIFE SITUATION !!! """
master_key = "0x3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F"

# Example usage for a 64-bit Fibonacci LFSR with hexadecimal initial state
# The LFSR taps are defined as the positions of the bits that are XORed with the feedback bit

# Define taps for a 64-bit LFSR
taps_64bit = [25, 19, 27, 3]
# Initial state in hexadecimal
initial_state_64bit_hex = 0x91C6B5A4F2E836D9  
num_bits_64bit = 64

#------------------------------------------------------------------------------------------#
# ASSUMPTION : THIS CODE BELOW ASSUME THAT THERE IS ALREADY a VALID PAIRING BETWEEN THE REMOTE AND THE RECEIVER
#  The Sender and the Receiver must share the same taps, initial state, and number of bits  #

# Dummy Serial number, Must be 8 bytes length 
serial_number = "0x0F0F0F0F0F0F0F0F"

""" Receiver Side """
# Create a Receiver object associated with the remote, must share the same taps, initial state, and number of bits
Receiver = RemoteReceiver(bytes.fromhex(master_key[2:]),
                            taps_64bit, 
                            initial_state_64bit_hex,
                            num_bits_64bit)

# Generate the initial rolling code windows of the receiver
receiver_raw_rolling_codes_window = Receiver.generate_rolling_code_values(5)
print("Receiver Generated Rolling Code Windows:", receiver_raw_rolling_codes_window)

# Generate the sender key.
# KDF of the serial number of the remote and the master key.
sender_key = Receiver.generate_sender_key(bytes.fromhex(serial_number[2:]))

#------------------------------------------------------------------------------------------#
#  The Sender and the Receiver must share the same sender key for the communication  #

""" Sender Side """
# Create a Sender object associated with the Receiver, must share the same taps, initial state, and number of bits
Sender = RemoteSender(bytes.fromhex(serial_number[2:]),
                      sender_key, taps_64bit, 
                      initial_state_64bit_hex, 
                      num_bits_64bit)

# Generate the initial rolling code window of the sender
sender_raw_rolling_codes_window = Sender.generate_rolling_code_values()
print("Sender Generated Rolling Code Windows:", sender_raw_rolling_codes_window)

# Extract the raw token (before encryption) from the rolling code window of the sender
sender_raw_token = sender_raw_rolling_codes_window[0][2:]
print("Sender Raw Token:", sender_raw_token)

# Generate the Token (encryption of the raw token) to be sent to the Receiver
Sender_Token = Sender.generate_token(bytes.fromhex(sender_raw_token))
print("Sender Encrypted Token:", binascii.hexlify(Sender_Token))

# ASSUMPTION : It is assumed that the Receiver received the message from the Sender
# Generate the message to be sent to the Receiver : Serial Number + Receiver Token
message = serial_number[2:] + Sender_Token[:8].hex()
print("Send Message:\t\t", message)

# ASSUMPTION : Verify if the Serial Number is known by the Receiver

# Extract the raw token (before encryption) from the rolling code window of the receiver
Receiver_Token = Receiver.generate_token(bytes.fromhex(serial_number[2:]),
                                         bytes.fromhex(sender_raw_token))
print("Computed Receiver Token:", binascii.hexlify(Receiver_Token[:8]))

Receiver_Tokens = [] 

# Compute the 5 next tokens of the receiver
for i in receiver_raw_rolling_codes_window:
    #print("Receiver Raw Token:", i[2:])
    Receiver_Tokens.append(bytes.hex(Receiver.generate_token(bytes.fromhex(serial_number[2:]),bytes.fromhex(i[2:]))[:8]))

print(Sender_Token[:8].hex())

# Verify if the Sender Token is within the Receiver Tokens (Rolling Code Window)
if Sender_Token[:8].hex() in Receiver_Tokens:
    print("The Sender Token is within the rolling code window of the Receiver")
else:
    print("The Sender Token is not within the rolling code window of the Receiver")

print("List of Actual Receiver Tokens:", Receiver_Tokens)


# Update the rolling code windows of the sender after a message is sent
updated_sender_raw_rolling_codes_window = Sender.update_lfsr_and_values(int(sender_raw_rolling_codes_window[0],16), 1)
print("Sender Updated Rolling Code Windows:", updated_sender_raw_rolling_codes_window)

# Update the rolling code windows of the receiver after a message is received and verified
updated_receiver_raw_rolling_codes_window = Receiver.update_lfsr_and_values(int(receiver_raw_rolling_codes_window[0],16), 10)
print("Receiver Updated Rolling Code Windows:", updated_receiver_raw_rolling_codes_window)



# if __name__ == '__main__':
#     main()